from __future__ import annotations
import logging
import math
import os
from typing import Dict, Tuple, List

from aiogram import types, Dispatcher
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.types import (
    InputFile,
    ReplyKeyboardRemove,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)

# –∞–Ω—Ç–∏-—Å–ø–∞–º / –∑–∞–Ω—è—Ç–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
from ..middlewares.busy import is_busy, set_busy, clear_busy, BUSY_TEXT

from ..services import parser_adapter
from ..services import validator  # –≤–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞

log = logging.getLogger(__name__)

# –ö–µ—à –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ ¬´—Å–æ–º–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ¬ª –∑–∞–ø—Ä–æ—Å–∞: user_id -> (query, city, overrides)
_WARN_CACHE: Dict[int, Tuple[str, str, dict]] = {}
# –ö–µ—à —à–∞–≥–∞ –≤—ã–±–æ—Ä–∞ –æ–±—ä—ë–º–∞: user_id -> (norm_title, city, area_id, overrides, max_total)
_PENDING_QTY: Dict[int, Tuple[str, str, int, dict, int]] = {}

# –≤–µ—Ä—Ö–Ω–∏–π –ª–∏–º–∏—Ç –¥–ª—è ¬´–í—Å—ë¬ª
MAX_EXPORT = int(os.getenv("MAX_EXPORT", "500"))
BIG_PER_PAGE = 100  # HH –¥–æ–ø—É—Å–∫–∞–µ—Ç –¥–æ 100


class ParseForm(StatesGroup):
    waiting_query = State()
    waiting_city = State()
    waiting_kw_include = State()
    waiting_kw_exclude = State()


# ---------- utils ----------
def _parse_overrides(parts: list[str]) -> dict[str, object]:
    overrides: dict[str, object] = {}
    for part in parts:
        if "=" not in part:
            raise ValueError("–û–ø—Ü–∏–∏ —É–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ key=value")
        key, value = [p.strip() for p in part.split("=", 1)]
        key = key.lower()
        if key == "pages":
            overrides["pages"] = int(value)
        elif key in {"per_page", "per-page"}:
            overrides["per_page"] = int(value)
        elif key == "pause":
            overrides["pause"] = float(value)
        elif key == "site":
            overrides["site"] = value.lower()
        elif key == "area":
            overrides["area"] = int(value)
        elif key == "include":
            overrides["include"] = _split_kw(value)
        elif key == "exclude":
            overrides["exclude"] = _split_kw(value)
        else:
            raise ValueError(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ–ø—Ü–∏—è: {key}")
    return overrides


def _split_kw(s: str) -> List[str]:
    return [p.strip() for p in s.replace(";", ",").split(",") if p.strip()]


async def _run_parser_bypass_validation(message: types.Message, query: str, city: str, overrides: dict):
    """–ó–∞–ø—É—Å–∫ –ø–∞—Ä—Å–µ—Ä–∞ –±–µ–∑ –¥–æ–ø. –ø—Ä–æ–≤–µ—Ä–æ–∫ (–ø–æ –∫–Ω–æ–ø–∫–µ ¬´–í—Å—ë —Ä–∞–≤–Ω–æ –∏—Å–∫–∞—Ç—å¬ª)."""
    uid = message.from_user.id
    if not set_busy(uid):
        await message.answer(BUSY_TEXT)
        return
    try:
        await message.answer("–û–∫–µ–π, –∑–∞–ø—É—Å–∫–∞—é –ø–æ–∏—Å–∫. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 1‚Äì2 –º–∏–Ω—É—Ç—ã‚Ä¶")
        path = await parser_adapter.run_report(
            uid,
            query,
            city,
            role=query,
            **overrides,
        )
    except Exception as e:  # pragma: no cover
        logging.exception("parser failed")
        err_text = (str(e) or "").strip() or "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç: –ø–∞—Ä—Å–µ—Ä –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ"
        await message.answer(err_text)
        return
    finally:
        clear_busy(uid)

    if path.exists():
        await message.answer_document(InputFile(path))
    else:
        await message.answer("–û—Ç—á—ë—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.")


async def _run_with_amount(message: types.Message, title: str, city: str, area_id: int, overrides: dict, total: int):
    """–°—á–∏—Ç–∞–µ—Ç pages/per_page –ø–æ–¥ –Ω—É–∂–Ω—ã–π –æ–±—ä—ë–º total –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç –ø–∞—Ä—Å–µ—Ä —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    uid = message.from_user.id
    if not set_busy(uid):
        await message.answer(BUSY_TEXT)
        return

    per_page = max(1, min(100, total))
    pages = max(1, math.ceil(total / per_page))

    ov = dict(overrides or {})
    ov.setdefault("area", area_id)
    ov["per_page"] = per_page
    ov["pages"] = pages

    # ‚ö° –±—ã—Å—Ç—Ä—ã–π —Ä–µ–∂–∏–º –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä—ë–º–æ–≤
    if total > 200:
        ov.setdefault("site", "hh")
        ov.setdefault("pause", 0.3)
        timeout = int(os.getenv("PARSER_TIMEOUT_LARGE", "1200"))
    else:
        timeout = None

    await message.answer(f"–û–∫–µ–π, –≤—ã–≥—Ä—É–∂–∞—é ~{min(total, per_page*pages)} –≤–∞–∫–∞–Ω—Å–∏–π‚Ä¶ —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç.")
    try:
        path = await parser_adapter.run_report(
            uid,
            title,
            city,
            role=title,
            timeout=timeout,
            **ov,
        )
    except Exception as e:
        logging.exception("parser failed")
        err_text = (str(e) or "").strip() or "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç: –ø–∞—Ä—Å–µ—Ä –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ"
        await message.answer(err_text)
        return
    finally:
        clear_busy(uid)

    if path.exists():
        await message.answer_document(InputFile(path))
    else:
        await message.answer("–û—Ç—á—ë—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.")


# ---------- core ----------
async def _run_parser(message: types.Message, query: str, city: str, overrides: dict[str, object]):
    # –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–Ω—è—Ç ‚Äî –º—è–≥–∫–æ –æ—Ç—à—å—ë–º —Å—Ä–∞–∑—É
    if is_busy(message.from_user.id):
        await message.answer(BUSY_TEXT)
        return

    # 1) –ú—è–≥–∫–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è
    ok, norm_title, area_id, bad_msg = validator.validate_request(query, city)
    if not ok:
        kb = InlineKeyboardMarkup(row_width=1)
        kb.add(
            InlineKeyboardButton("‚úÖ –í—Å—ë —Ä–∞–≤–Ω–æ –∏—Å–∫–∞—Ç—å (—Å–ø–∏—Å–∞—Ç—å 1 –∫—Ä–µ–¥–∏—Ç)", callback_data="parse_force"),
            InlineKeyboardButton("‚úèÔ∏è –ò—Å–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å", callback_data="parse_fix"),
        )
        _WARN_CACHE[message.from_user.id] = (query, city, overrides)
        await message.answer(
            bad_msg
            + "\n\n–ï—Å–ª–∏ —Ç—ã —É–≤–µ—Ä–µ–Ω(–∞) ‚Äî –º–æ–≥—É –≤—Å—ë —Ä–∞–≤–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ–∏—Å–∫. "
              "–≠—Ç–æ –º–æ–∂–µ—Ç —Å–ø–∏—Å–∞—Ç—å 1 –∫—Ä–µ–¥–∏—Ç/–ª–∏–º–∏—Ç.",
            reply_markup=kb,
        )
        await ParseForm.waiting_query.set()
        return

    # 2) –ï—Å–ª–∏ —é–∑–µ—Ä —Å–∞–º –∑–∞–¥–∞–ª pages/per_page ‚Äî –∑–∞–ø—É—Å–∫–∞–µ–º –±–µ–∑ —à–∞–≥–∞ –æ–±—ä—ë–º–∞ (–∏ –±–ª–æ–∫–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
    if "pages" in overrides or "per_page" in overrides:
        uid = message.from_user.id
        if not set_busy(uid):
            await message.answer(BUSY_TEXT)
            return
        try:
            await message.answer("–°–æ–±–∏—Ä–∞—é –≤–∞–∫–∞–Ω—Å–∏–∏, —ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç‚Ä¶")
            if "area" not in overrides:
                overrides["area"] = area_id
            path = await parser_adapter.run_report(
                uid,
                norm_title,
                city,
                role=norm_title,
                **overrides,
            )
        except Exception as e:
            logging.exception("parser failed")
            err_text = (str(e) or "").strip() or "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á—ë—Ç: –ø–∞—Ä—Å–µ—Ä –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ"
            await message.answer(err_text)
            return
        finally:
            clear_busy(uid)

        if path.exists():
            await message.answer_document(InputFile(path))
        else:
            await message.answer("–û—Ç—á—ë—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.")
        return

    # 3) –®–∞–≥ –≤—ã–±–æ—Ä–∞ –æ–±—ä—ë–º–∞ (—á–∏—Å–ª–æ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –ù–ï –ø–æ–∫–∞–∑—ã–≤–∞–µ–º)
    ok_probe, found = validator.probe_hh_found(norm_title, area_id)
    max_total = min(found, MAX_EXPORT) if ok_probe and isinstance(found, int) else MAX_EXPORT

    kb = InlineKeyboardMarkup(row_width=3)
    kb.row(
        InlineKeyboardButton("60", callback_data="qty:60"),
        InlineKeyboardButton("200", callback_data="qty:200"),
        InlineKeyboardButton(f"–í—Å—ë (–¥–æ {MAX_EXPORT})", callback_data="qty:all"),
    )
    # –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–µ—Ä–≤—ã—Ö 5 ‚Äî –ª—ë–≥–∫–∏–π –∑–∞–ø—Ä–æ—Å; —Ç–æ–∂–µ —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π
    kb.row(InlineKeyboardButton("üëÄ –ü—Ä–µ–≤—å—é (5)", callback_data="preview:5"))

    _PENDING_QTY[message.from_user.id] = (norm_title, city, area_id, overrides, max_total)
    await message.answer("–í—ã–±–µ—Ä–∏ –æ–±—ä—ë–º –≤—ã–≥—Ä—É–∑–∫–∏:", reply_markup=kb)


# ---------- /parse ----------
async def cmd_parse(message: types.Message, state: FSMContext):
    if is_busy(message.from_user.id):
        await message.answer(BUSY_TEXT)
        return

    args = message.get_args()
    if args:
        raw_parts = [p.strip() for p in args.split(";") if p.strip()]
        if len(raw_parts) < 2:
            await message.reply("–ò—Å–ø–æ–ª—å–∑—É–π —Ñ–æ—Ä–º–∞—Ç: /parse –¥–æ–ª–∂–Ω–æ—Å—Ç—å; –≥–æ—Ä–æ–¥; pages=1")
            return
        query, city, *rest = raw_parts
        overrides: dict[str, object] = {}
        if rest:
            try:
                overrides = _parse_overrides(rest)
            except ValueError as exc:
                await message.reply(str(exc))
                return
        await _run_parser(message, query, city, overrides)
        return

    await message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–æ–ª–∂–Ω–æ—Å—Ç—å:", reply_markup=ReplyKeyboardRemove())
    await ParseForm.waiting_query.set()


async def process_query(message: types.Message, state: FSMContext):
    if is_busy(message.from_user.id):
        await message.answer(BUSY_TEXT)
        return
    await state.update_data(query=message.text.strip())
    await message.answer("–ì–æ—Ä–æ–¥?")
    await ParseForm.waiting_city.set()


async def process_city(message: types.Message, state: FSMContext):
    if is_busy(message.from_user.id):
        await message.answer(BUSY_TEXT)
        return
    data = await state.get_data()
    query = data.get("query")
    city = message.text.strip()
    kb = InlineKeyboardMarkup().row(
        InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–ª—é—á–µ–≤—ã–µ", callback_data="kw_yes"),
        InlineKeyboardButton("–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="kw_no"),
    )
    await state.update_data(city=city)
    await message.answer("–•–æ—á–µ—à—å —É—Ç–æ—á–Ω–∏—Ç—å –ø–æ–∏—Å–∫ –∫–ª—é—á–µ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏ (–≤–∫–ª—é—á–∏—Ç—å/–∏—Å–∫–ª—é—á–∏—Ç—å)?", reply_markup=kb)


# ---------- –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ (include/exclude) ----------
async def cb_kw_yes(call: types.CallbackQuery, state: FSMContext):
    if is_busy(call.from_user.id):
        await call.answer(BUSY_TEXT, show_alert=False)
        return
    await call.answer()
    await call.message.answer(
        "–í–≤–µ–¥–∏ —Å–ª–æ–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ –î–û–õ–ñ–ù–´ –≤—Å—Ç—Ä–µ—á–∞—Ç—å—Å—è (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é). –ü—Ä–∏–º–µ—Ä: —ç–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫–∞, b2b, pcb.\n"
        "–ï—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–æ ‚Äî –ø—Ä–∏—à–ª–∏ –ø—É—Å—Ç–æ –∏–ª–∏ ¬´-¬ª.",
        reply_markup=ReplyKeyboardRemove(),
    )
    await ParseForm.waiting_kw_include.set()


async def cb_kw_no(call: types.CallbackQuery, state: FSMContext):
    if is_busy(call.from_user.id):
        await call.answer(BUSY_TEXT, show_alert=False)
        return
    await call.answer()
    data = await state.get_data()
    query = data.get("query")
    city = data.get("city")
    await state.finish()
    await _run_parser(call.message, query, city, {})  # –±–µ–∑ —É—Ç–æ—á–Ω–µ–Ω–∏–π


async def process_kw_include(message: types.Message, state: FSMContext):
    if is_busy(message.from_user.id):
        await message.answer(BUSY_TEXT)
        return
    txt = (message.text or "").strip()
    include = [] if txt in {"", "-"} else _split_kw(txt)
    await state.update_data(include=include)
    await message.answer(
        "–¢–µ–ø–µ—Ä—å —Å–ª–æ–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ –ù–£–ñ–ù–û –∏—Å–∫–ª—é—á–∏—Ç—å (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é). –ü—Ä–∏–º–µ—Ä: —Å—Ç–∞–∂—ë—Ä, –ø–æ–º–æ—â–Ω–∏–∫.\n"
        "–ï—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–æ ‚Äî –ø—Ä–∏—à–ª–∏ –ø—É—Å—Ç–æ –∏–ª–∏ ¬´-¬ª.",
    )
    await ParseForm.waiting_kw_exclude.set()


async def process_kw_exclude(message: types.Message, state: FSMContext):
    if is_busy(message.from_user.id):
        await message.answer(BUSY_TEXT)
        return
    txt = (message.text or "").strip()
    exclude = [] if txt in {"", "-"} else _split_kw(txt)
    data = await state.get_data()
    query = data.get("query")
    city = data.get("city")
    include = data.get("include", [])
    await state.finish()
    await _run_parser(message, query, city, {"include": include, "exclude": exclude})


# ---------- callbacks –∏–∑ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è / –æ–±—ä—ë–º / –ø—Ä–µ–≤—å—é ----------
async def cb_parse_force(call: types.CallbackQuery, state: FSMContext):
    if is_busy(call.from_user.id):
        await call.answer(BUSY_TEXT, show_alert=False)
        return
    payload = _WARN_CACHE.pop(call.from_user.id, None)
    await call.answer()
    if not payload:
        await call.message.answer("–ù–µ –Ω–∞—à—ë–ª –ø–æ—Å–ª–µ–¥–Ω–∏–π –∑–∞–ø—Ä–æ—Å. –í–≤–µ–¥–∏ –¥–æ–ª–∂–Ω–æ—Å—Ç—å –µ—â—ë —Ä–∞–∑:")
        await ParseForm.waiting_query.set()
        return
    query, city, overrides = payload
    try:
        await state.finish()
    except Exception:
        pass
    await _run_parser_bypass_validation(call.message, query, city, overrides)


async def cb_parse_fix(call: types.CallbackQuery):
    if is_busy(call.from_user.id):
        await call.answer(BUSY_TEXT, show_alert=False)
        return
    _WARN_CACHE.pop(call.from_user.id, None)
    await call.answer()
    await call.message.answer("–û–∫–µ–π! –í–≤–µ–¥–∏ –¥–æ–ª–∂–Ω–æ—Å—Ç—å –µ—â—ë —Ä–∞–∑:", reply_markup=ReplyKeyboardRemove())
    await ParseForm.waiting_query.set()


async def cb_qty(call: types.CallbackQuery):
    # –µ—Å–ª–∏ –∑–∞–Ω—è—Ç ‚Äî –ø—Ä–æ—Å—Ç–æ –ø–æ–¥—Å–∫–∞–∑–∫–∞ –∏ –≤—ã—Ö–æ–¥–∏–º
    if is_busy(call.from_user.id):
        await call.answer(BUSY_TEXT, show_alert=False)
        return

    payload = _PENDING_QTY.get(call.from_user.id)
    await call.answer()
    if not payload:
        await call.message.answer("–ù–µ –Ω–∞—à—ë–ª –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å. –í–≤–µ–¥–∏ –¥–æ–ª–∂–Ω–æ—Å—Ç—å –µ—â—ë —Ä–∞–∑:")
        await ParseForm.waiting_query.set()
        return

    title, city, area_id, overrides, max_total = payload
    choice = call.data.split(":", 1)[1]
    if choice == "60":
        total = 60
    elif choice == "200":
        total = 200
    else:  # "all"
        total = max_total

    # —Ñ–∏–∫—Å: –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞ –≤—ã–≥—Ä—É–∑–∫–∏ ¬´–∑–∞–±—ã–≤–∞–µ–º¬ª pending, —á—Ç–æ–±—ã —Å—Ç–∞—Ä—ã–µ –∫–Ω–æ–ø–∫–∏ –Ω–µ –ø–ª–æ–¥–∏–ª–∏ –æ—à–∏–±–∫–∏
    _PENDING_QTY.pop(call.from_user.id, None)
    await _run_with_amount(call.message, title, city, area_id, overrides, total)


async def cb_preview(call: types.CallbackQuery):
    """–ü–æ–∫–∞–∑–∞—Ç—å 5 –ø–µ—Ä–≤—ã—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –±–µ–∑ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è –∫–µ—à–∞ –∑–∞–ø—Ä–æ—Å–∞."""
    await call.answer("–ì–æ—Ç–æ–≤–ª—é –ø—Ä–µ–≤—å—é‚Ä¶", show_alert=False)

    uid = call.from_user.id
    payload = _PENDING_QTY.get(uid)   # –í–ê–ñ–ù–û: .get(), –ù–ï .pop()!
    if not payload:
        await call.message.answer("–ù–µ –Ω–∞—à—ë–ª –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å. –í–≤–µ–¥–∏ –¥–æ–ª–∂–Ω–æ—Å—Ç—å –µ—â—ë —Ä–∞–∑:")
        await ParseForm.waiting_query.set()
        return

    title, city, area_id, overrides, _max_total = payload
    include = (overrides or {}).get("include") or []
    exclude = (overrides or {}).get("exclude") or []

    try:
        rows = await parser_adapter.preview_rows(
            title, city, area_id=area_id, include=include, exclude=exclude
        )
    except Exception:
        logging.exception("preview failed")
        await call.message.answer("‚è≥ –ü—Ä–µ–≤—å—é –Ω–µ —É—Å–ø–µ–ª–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
        return

    if not rows:
        await call.message.answer("–°–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ –Ω–∞—à–ª–æ—Å—å –ø–æ —Ç–µ–∫—É—â–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º.")
        return

    # –∞–∫–∫—É—Ä–∞—Ç–Ω—ã–π —Ç–µ–∫—Å—Ç –ø—Ä–µ–≤—å—é
    lines = []
    for r in rows:
        t = r.get("title") or "‚Äî"
        c = r.get("company") or "‚Äî"
        s = r.get("salary") or "‚Äî"
        link = r.get("link")
        if link:
            lines.append(f"‚Ä¢ <a href=\"{link}\">{t}</a> ‚Äî {c} ‚Äî {s}")
        else:
            lines.append(f"‚Ä¢ {t} ‚Äî {c} ‚Äî {s}")

    txt = "<b>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä (–ø–µ—Ä–≤—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è):</b>\n" + "\n".join(lines)
    await call.message.answer(txt, disable_web_page_preview=True)


def register(dp: Dispatcher):
    # –∫–æ–º–∞–Ω–¥—ã –∏ –¥–∏–∞–ª–æ–≥
    dp.register_message_handler(cmd_parse, commands=["parse"], state="*")
    dp.register_message_handler(cmd_parse, lambda m: m.text == "üîé –ü–æ–∏—Å–∫", state="*")
    dp.register_message_handler(process_query, state=ParseForm.waiting_query)
    dp.register_message_handler(process_city, state=ParseForm.waiting_city)

    # –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
    dp.register_callback_query_handler(cb_kw_yes, lambda c: c.data == "kw_yes", state="*")
    dp.register_callback_query_handler(cb_kw_no,  lambda c: c.data == "kw_no",  state="*")
    dp.register_message_handler(process_kw_include, state=ParseForm.waiting_kw_include)
    dp.register_message_handler(process_kw_exclude, state=ParseForm.waiting_kw_exclude)

    # –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ/–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ–º–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    dp.register_callback_query_handler(cb_parse_force, lambda c: c.data == "parse_force", state="*")
    dp.register_callback_query_handler(cb_parse_fix,   lambda c: c.data == "parse_fix",   state="*")

    # –≤—ã–±–æ—Ä –æ–±—ä—ë–º–∞ –∏ –ø—Ä–µ–≤—å—é
    dp.register_callback_query_handler(cb_qty,     lambda c: c.data and c.data.startswith("qty:"),     state="*")
    dp.register_callback_query_handler(cb_preview, lambda c: c.data and c.data.startswith("preview:"), state="*")
